###### tags: `MDOI`

# 小群體定理

#### 作者：iceylemon157

---

## APCS題 小群體

---

先說，其實沒有這個定理，這個名字是我亂取的。而且他其實不是一個定理，而是好幾個(x。

這個名字是從某次2017年APCS的第二題來的。

讓我們直接來看例題吧。
### [[APCS 小群體]](https://zerojudge.tw/ShowProblem?problemid=c291)

題目如下：
給定一個 $1\sim n$ 的排列 $P$。$P_i$ 代表第 $i$ 個人跟 $P_i$ 是朋友。朋友關係具有傳遞性，即如果 $A$ 跟 $B,C$ 都是朋友，那麼 $B$ 跟 $C$ 也是朋友。請問至少可以把這些人分成幾個小群體，使得每一個小群體的任兩個人都是朋友。

### 講解

對併查集有了解的同學可能第一眼看到這題就會想說這題可以用併查集輕鬆解決。而併查集會帶一個 $O(\alpha(N))$，雖然他是線性。但這題是APCS第二題，那他當然不會是一個多難的題目，也不會需要什麼太難的演算法或是要自己手刻資料結構。

我們可以沿著一個人一直往他的朋友找下去，可以找到的人全部都把它分到同一組。然後呢？沒了。最後作完之後組別的數量就是答案。

實作方面要怎麼處理呢？如果你有學過一個演算法叫作DFS，那麼你會發現可以直接用DFS做下去。但這題是第二題，不會需要用到演算法(雖然他並不難)。更何況，遞迴狠慢，不要遞迴。可以發現，上面講的其實這件事情可以直接用while迴圈做到。

幹嘛要講那麼多啊？反正都是線性我想打哪一個就打哪一個？是這樣沒錯啦，但是我認為運用題目性質讓自己可以不用用任何演算法就解出一道題目是個值得一學的一件事。而且這也提醒了我們，不要演算法中毒。

這邊附上用while迴圈實作的程式碼：
:::spoiler 參考code
```cpp=
#include<bits/stdc++.h>
using namespace std;
const int maxn = 3e6 + 50;

int n, a[maxn], cnt;
bitset<maxn> vis;

signed main() {
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> a[i], a[i] ++;
    for(int i = 1; i <= n; i ++) {
        if(!vis[i]) {
            int t = i;
            while(!vis[t]) {
                vis[t] = 1;
                t = a[t];
            }
            cnt ++;
        }
    }
    cout << cnt << "\n";
}
```
:::

雖然這是一道簡單的題目，但是其實這題他有一個非常值得注意的一個小性質。那就是我們今天要講的主題：

---

## 定理1：小群體定理

給定一個 $1\sim n$ 的排列 $P$。$P_i$ 代表第 $i$ 個人跟 $P_i$ 是朋友。如果將 $i$ 到 $P_i$ 連一條邊。那麼最後所有點都會在一個環內(包含自環)。

---

這個定理的用感受的會特別直觀。因為每個點的deg都是2，所以不會出現有點不在環中。(需要有至少一個點的deg為1才會不屬於環)。

這個定理的應用非常的廣，有很多題目都會偷偷塞這個觀念進來。

來一題簡單的題目來練練手吧：

---

## 例題1

給定一個排列 $P$，$P_i$ 代表第 $i$ 個人跟 $P_i$ 是朋友。朋友關係具有傳遞性，即如果 $A$ 跟 $B,C$ 都是朋友，那麼 $B$ 跟 $C$ 也是朋友。

現在想要讓全部的人認識，每次操作要由兩個沒有朋友關係的人去認識對方，並且要花費兩個人朋友的數量的時間。也就是說如果 $A$ 原本認識了 $k$ 個人(包含他自己)，$B$ 原本認識了 $m$ 個人(包含他自己)。$A$ 跟 $B$ 認識要花費 $k+m$ 的時間。

請問最少要花多少時間才可以讓全部的人都認識。

### 講解

如果有了小群體定理，就可以知道我們可以在 $O(N)$ 的時間內找出某一個人有幾個朋友，每一個小群體有多少人。而這時候我們就會發現它變成一個簡單的經典題了 -- [合併果子問題](https://zerojudge.tw/ShowProblem?problemid=b151)。於是這題就解決了。

參考code:
```cpp=
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 1e6 + 50;

int n, p[maxn];
priority_queue<int, vector<int>, greater<int>> pq;
bitset<maxn> vis;

signed main() {
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> p[i];
    for(int i = 1; i <= n; i ++) {
        if(!vis[i]) {
            int t = i, cnt = 0;
            while(!vis[t]) {
                vis[t] = 1;
                cnt ++;
                t = p[t];
            }
            pq.push(cnt);
        }
    }
    int ans = 0LL;
    while((int)pq.size() >= 2) {
        int a = pq.top(); pq.pop();
        int b = pq.top(); pq.pop();
        ans += a + b;
        pq.push(a + b);
    }
    cout << ans << "\n";
}
```

再來看一題類似的題目吧：

## 例題2

給定一個排列 $P$，$P_i$ 代表第 $i$ 個人跟 $P_i$ 是朋友。朋友關係具有傳遞性，即如果 $A$ 跟 $B,C$ 都是朋友，那麼 $B$ 跟 $C$ 也是朋友。

現在我想要選**恰好** $k$ 個人參加聚會，如果一個人參加聚會了，那他的所有朋友也一定都會參加聚會。請問有幾種選取的方案？

### 講解

恰好 $k$ 個這件事要怎麼做呢？如果之前動態規劃課有好好聽懂的話，應該可以聯想到 **背包問題** 這件事。那這題就做完了。
[[這題的背包問題原題]](https://www.luogu.com.cn/problem/P1164)

----

前面兩個都只是小群體定理的基本應用而已，現在我們再來介紹另外一個定理。

---

## 定理2：小群體交換定理

對於一個長度為 $n$ 的環，至少要經過 $n-1$ 次交換才可以使環中所有點都變成一個自環。

---

定理2證明：顯然 $n=2$ 時只需要一次，滿足命題。假設對於所有 $k\leq n$ 都滿足命題。如果在一個環長度為 $n+1$ 的環內進行一次交換，會把它拆成兩個長度小於 $n+1$ 的 環。不妨令兩個環的長度分別為 $a,b$。那麼可以知道至少需要 $(a-1)+(b-1)+1=n$ 次交換。由數學歸納法得證。

----

### 延伸：印出一組解

----

### 例題3

[[NPSC pre-2016 pD]](http://mdcpp.mingdao.edu.tw/problem/C024)

總共有 $N$ 個祭壇，第 $i$ 個祭壇編號為 $i$。
每個祭壇上面放了一個編號為 $P_i$ 的水晶球。
並且每個祭壇有 $T_i$ 的法力值。
現在想要讓每個水晶球放到他對應編號的祭壇上。
每次可以選兩個祭壇交換。
假設兩個祭壇分別為編號 $i,j$，
那麼交換的代價是 $min(T_i,T_j)$。
請問最少要花多少代價才可以達成要求。

----

### 講解

由小群體交換定理可以知道我們只要換 $n-1$ 次就可以了，而且交換的方式可以固定一個祭壇再選另外一個祭壇交換。

舉個例子： $P=\{2,3,4,5,1\}$
如果我都在固定其中一個祭壇一定要在第一個祭壇。那個交換的方式如下：
$\{2,3,4,5,1\}\rightarrow\{3,2,4,5,1\}\rightarrow\{4,2,3,5,1\}\rightarrow\{5,2,3,4,1\}\rightarrow\{1,2,3,4,5\}$

這也就告訴了我們，我們可以固定一個祭壇然後用他一直跟他所屬的小群體的其他祭壇交換，把整個小群體全部變成自環。

接下來我們分兩個 $Case$ 討論：

$Case\ 1$：
如果同一個小群體的祭壇都只跟同一個小群體內交換，那麼Greedy告訴我們，答案就會是這個小群體裡面最小的 $T_x$，乘上這個小群體的大小 $-1$。

假設總共有 $k$ 個小群體，第 $i$ 個小群體的大小為 $sz[i]$，第 $i$ 個小群體的最小 $T$ 值為 $mn[i]$。

也就是說這種 $Case$把第 $Ii$ 個小群體全部拆成自環的代價會是 $mn[i]\cdot(sz[i]-1)$

$Case\ 2$：
如果有一次交換兩個祭壇不同屬於一個小群體，那麼用貪心的思想可以知道其中一個祭壇的 $T$ 值要是所有祭壇的 $T$ 值中最小的那一個。假設 $mmin=min\{T_i\}$。而進行完這次交換之後，可以利用 $mmin$ 把另外一個祭壇所屬的小群體全部換掉，再把 $mmin$ 還原到他原本所屬的小群體內。這樣子把第 $i$ 個小群體全部拆掉的代價會是 $mmin*(sz[i]+1)$。

那麼結合上面兩個 $Case$，可以得到答案就會是：
$\sum\limits_{i=1}^{k}min(mn[i]\cdot(sz[i]-1),mmin\cdot(sz[i]+1))$

整題複雜度是 $O(N)$ 級別。

---

## 習題

用到這些觀念的題目實在是太多了，這邊會放一些比較簡單的題目跟一些可能會需要用到比較高階技巧的題目。大概會按難度排序，大概啦。

[[2015高雄市資訊學科能力競賽 p5]](https://zerojudge.tw/ShowProblem?problemid=b685) DP

[[Atcoder ARC111 pC]](https://atcoder.jp/contests/arc111/tasks/arc111_c)

[[IPSC2016 pC]](https://www.luogu.com.cn/problem/solution/P4778) 想法簡單，優化毒瘤

[[CF 755F]](https://codeforces.com/contest/755/problem/F) 這題會用到一點優化的技巧，有點小難。
