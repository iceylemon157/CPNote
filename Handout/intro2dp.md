---
title: 動態規劃初探
tags: MDCPP
slideOptions:
    theme: solarized
    transition: 'slide'
---

#### MDCPP進階組培訓講義05

## 動態規劃初探
#### 作者：iceylemon

---

## 複習time

----

## 時間複雜度

----

還記得什麼是時間複雜度嗎?
我們再來複習一下吧!

----

時間複雜度可以想像成你的程式大概跑了幾次
```cpp=
int t = 0;
for(int i = 0; i < n; i ++){
    for(int j = 0; j < n; j ++){
        t ++;
    }
}
```
==> $O(N^2)$


----

時間複雜度可以想像成你的程式大概跑了幾次
```cpp=
int t = 0;
for(int i = 0; i < n; i ++) t ++;

for(int i = 0; i < n; i ++) t ++;

```

==> $O(N) + O(N) = O(2N) = O(N)$


----

算時間複雜度有什麼用呢?
題目通常會給我們測資範圍
我們可以估計我們的程式的時間複雜度
大概要多少才會過！

----

以下是常見的表格(一秒內)
| 複雜度 | 對應次數 |
| -------- | -------- |
| $O(N)$    | 1e7 ~ 1e8  以下 |
| $O(NlogN)$| 1e5 ~ 1e6 以下 |
| $O(N^2)$ | 5e3 ~ 1e4 以下 |
| $O(N^3)$ | 300 ~ 500 以下 |
| $O(2^N)$ | 25 以下 |
注意一下這邊的 $log$ 是以2為底的

----

### 複習一下 $log$

當我們有一個式子
$y=2^x$ 
此時會有
$log_2y=x$
也就是說你這的y是2的幾次方

----

#### 名詞解釋 -- 常數

常數的意思就是你的多項式前面的係數
或者是一些原本被我們忽略掉的東西
因為$O(2N)$跟$O(1000000N)$我們都會簡寫成$O(N)$
但顯然後者看起來就很慢，這也就是常數的差異


----

作為練習
希望大家以後可以把自己解出來的題目
都分析一下時間複雜度
在解題之前先算自己的程式會不會超時再開始打程式
不然可能打完程式碼才發現TLE，會浪費很多時間

---

## 動態規劃是什麼

----

### 動態規劃名字

動態規劃，英文叫 $Dynamic Programming$，簡稱DP。
那動態規劃動態在哪裡，規劃又在哪裡呢?

----

### Story Time
```
在1950年代，有一位數學家叫做Richard Bellman
他當時在一家公司工作，但是他的老闆非常不喜歡數學研究
於是他需要要找一個詞聽起來跟數學沒什麼關聯
而又不帶有任何的貶義，才能隱瞞過他的老闆

一開始他想要用"Planning"
但是他後來覺得"Planning"可能不是太好
他就發現一個很精準又聽起來很厲害的字"Programming"
這個字聽起來既不數學，聽起來又很厲害，根本就是絕配！

再來，他想要更有說服力一點
他想要說這是多階段性的一個東西
所以他就採用了"Dynamic"這個字
這個字除了很可以精確表達他想要講的東西之外
不管怎麼排列組合都不會排出帶有負面意義的詞

所以合在一起就變成"Dynamic Programming"
那他動態在哪規劃在哪呢?
這是個很好的問題 つづく...
```

[原文連結](https://web.archive.org/web/20180224201537/http://learning.cis.upenn.edu/cis520_fall2009/index.php?n=Notes.DP)

----

### DP是演算法嗎?

事實上DP是一種演算法的設計技巧
他並不是一種的演算法，不具有固定的流程或是打法
因為沒有固定打法，全靠自己的想法推出來
所以很常出現在程式競賽跟面試當中

----


### DP的精髓

DP是什麼呢，有兩個詞可以精準的描述這個東西

$DP$ = $Brute Force$ + $Memorization$

----

### DP的精髓

也就是說 DP = 暴力 + 記憶化
為什麼這麼說呢?
我們可以來看看下面這個大家熟知的問題

----

### Fibonacci Numbers

$F_0=1$, $F_1=1$, $F_n=F_{n-1}+F_{n-2}   ,  \forall n\in N$
求解 $F_k$ 為多少，其中 $k<=30$

----

如果大家還記得的話，其實我們第二堂課就有教過了
所以我們應該可以很快的用遞迴打出以下程式碼
```cpp
int fibo(int n){
    if(n == 0) return 1;
    if(n == 1) return 1;
    return fibo(n - 1) + fibo(n - 2);
}
```

----

那時間呢?
我們如果用以下程式測時間
```cpp=
double st, ed;
st = clock();
fibo(30);
ed = clock();
cout << ed - st << "\n";
```
我們會得到他跑了6000毫秒左右的答案。

----

好久阿，但是為什麼呢?
我們可以看看下面的這張圖

![](https://i.imgur.com/F5qxFqH.png)

[原圖連結](https://www.itread01.com/content/1568099222.html)
我們來算一下他的時間複雜度吧!

----

上面那張圖的總點數也就代表著執行了幾次
我們可以發現，每一個點都只會向下延伸兩條邊
也就是說從上往下數第一層，第二層....
每一層都只會有 $2^n$ 個點
如果有 $n$ 層的話，最多就只會有
$2^0+2^1+2^2...+2^{n-1}=2^n-1$個點
所以說我們的時間複雜度是$O(2^n)$

----

顯然上面那個作法整個超暴力
但我們其實可以發現一件事情
#### "很多數都不只出現了一次"
所以我們就想說，如果把那些已經出現的東西記起來
我們不就不用重複計算了嗎?

----

所以跟第二堂課講的一樣
這個作法就是老蔣早就提出來的一個作法
### 用空間換取時間
也就是 暴力(先寫出怎麼做) + 記憶化(紀錄他不讓他重複算到)

----

這樣我們可以把程式碼寫成下面的樣子
```cpp=
int dp[40];
int fibo(int n){
    if(n <= 1) return 1;
    if(dp[n]) return dp[n];
    return dp[n] = fibo(n - 1) + fibo(n - 2);
}
```
容易算出因為每個點只會被算到一次
所以時間複雜度是$O(N)$

----

我們僅僅利用了記憶化的這個動作
就讓我們的時間複雜度從$O(2^N)$ 變成了$O(N)$
這是個很大的進展!
這也就是DP的精隨

---

## 動態規劃要怎麼用

----

通常動態規劃都是拿來處理 最優解問題
或者也有人說  最佳化問題

----

如果要用動態規劃的話我們要滿足以下兩個條件
1. 最優子結構性質
2. 重疊子問題

----

### 最優子結構性質

可以把大問題分成小問題
並且我們可以利用很多小問題的最優解
來得到大問題的最優解
換句話說就是把小問題處理完之後我們可以推到大問題

----

### 重疊子問題

在求解大問題的時候
我們會時常重複利用到小問題的答案(如費氏數列)
如果沒有的話，那也就不需要記憶化了

----

## DP的寫法

----

DP的寫法分成兩種
一種叫做 top-down
一種叫做 bottom-up

----

### bottom-up

bottom-up的形式就是利用for迴圈遞推
從小的問題往上推到大的問題
如果同樣以費氏數列為例子來寫的話就會是
```cpp=
int dp[100005];
dp[0] = dp[1] = 1;
for(int i = 2; i <= n; i ++){
    dp[i] = dp[i - 1] + dp[i - 2];
}
```

----

### top-down

top-down的寫法就是我們在求解費氏數列的方法
也就是遞迴的方法去寫
通常用top-down會比較直觀

----

大家可能會覺得top-down比較好想也比較直觀
但我們通常會採用bottom-up的方式實做
但實際上因為top-down是採用遞迴的方式去實做
而使用遞迴的速度會比較慢
另外一個原因是，用bottom-up的方式去寫dp
比較容易真正了解dp在做什麼
而也才能體會出"順序"的差異以及dp真正的精髓

----

## 狀態與轉移

----

### 經典題：走樓梯問題

總共有$n$層階梯，你目前站在第0階
你每次可以選擇要走1階或是2階的階梯，請問你走到第n階有幾種方法數?
例子：當$n$ = 4時，有以下五種方法
```
1 1 1 1
1 1 2
1 2 1
2 1 1
2 2
```

[題目連結](http://mdcpp.mingdao.edu.tw/problem/A048)

----

### 經典題：走樓梯問題

考慮走到第 $i$ 層的狀況，我們要怎麼走才會走到第 $i$ 層呢?
我們只有兩種方法，一種是從 $i$ - 2 走兩層到第 $i$ 層
另外一種是從 $i$ - 1 層一層到第 $i$ 層

----

### 經典題：走樓梯問題

所以如果我們用一個 定義$dp[i]$ 代表走到第 $i$ 層有幾種方法，那我們就可以得到一個結論：
$dp[i]=dp[i-1]+dp[i-2]$
也就是費氏數列，所以我們就可以把他算出來了

----

### 狀態

在上面的例子當中，我們定義$dp[i]$ 代表走到第 $i$ 層有幾種方法
而事實上，這就是我們這個DP式的"狀態"
我們來看看狀態是什麼

----

### 狀態

用一些數字為一組為一個"狀態"，來表達一個情境
一個DP式可能會有多種狀態。(也就是多維陣列)

----

### 狀態

如果在某些情況在未來會有相同的發展
我們可以把他合併到同一個狀態
舉個例子：雖然我們用了不同方法走到了第3層
但是他們從第3階走到第4階的發展是一樣的
所以可以把走到第3階的所有情形合併到同一個狀態
將越多的情形壓縮在越少的狀態數下通常會越有效率

----

### 如何思考狀態

首先我們可以先觀察題目
先想辦法寫出一個狀態，然後再推看看他的轉移式
如果發現不可行就要考慮換一個狀態
通常先從直觀的想法開始
根據題目的特性去思考狀態要是什麼

----

### 轉移

轉移就是要如何利用小問題去推到大問題
也就是說寫出小問題跟大問題的關係式

例如爬樓梯問題的轉移式如下
$dp(n)=dp(n-1)+dp(n-2)$

----

### 要如何求得轉移式？

我們通常可以這樣思考：
假設我們已經得到小問題的解了
我們要怎麼把他變成大問題的解?

----

### 要如何求得轉移式？

這個時候我們要做一件事
#### "我們要相信我們的小問題的解是對的"
先思考我們要怎麼樣從小問題的解變成大問題的解
最後再處理初始條件或是邊界條件

----

### 例題：爬樓梯問題之二

題目跟上面一樣，但是現在有些樓梯壞掉了不能走
求走到第 n 階的方法數
因為方法數會很大，請輸出模 1e9 + 7 的方法數
[題目連結](http://mdcpp.mingdao.edu.tw/problem/A049)

----

### 取模

什麼是取模呢?
就是取餘數的意思
我們會用下面的方法來表示
$5\equiv 2\pmod{3}$
意思就是5對於3的餘數是2

----

### 解析

其實可以每遇到壞掉的樓梯就直接continue不計算他
因為他對答案沒有貢獻
所以只需要加continue就可以了

----

#### 參考code
```cpp=
const int mod = 1e9 + 7;
int dp[1000005];
bool no[1000005];

signed main(){
    int n, k;
    cin >> n >> k;
    for(int i = 1; i <= k; i ++){
        int a;
        cin >> a;
        no[a] = 1;
    }
    dp[0] = dp[1] = 1LL;
    for(int i = 2; i <= n; i ++){
        if(no[i]) continue;
        dp[i] = (dp[i - 1] + dp[i - 2]) % mod;
    }
    cout << dp[n] << endl;
}
```


----

### 爬樓梯問題之三(hard)

總共有 n 層階梯，你目前站在第0階
你每次可以選擇要走1階, 2階或 3階的階梯
但是你不能連續兩次走相同的階數
也就是說不能連續兩次走1階或是連續兩次走2階等等
請問你走到第n階有幾種方法數?(答案對1e9+7取模)
[題目連結](http://mdcpp.mingdao.edu.tw/problem/A050)

----

DP的兩大要素是什麼呢?
#### 狀態跟轉移
所以我們就先來想想看這題的狀態吧

----

可以發現一件事情，如果我們跟上面一樣用
$dp[i]$ 代表走到第 $i$ 層有幾種方法
會不知道上一次走的是哪一步，就會有點小問題
所以這題的狀態要怎麼寫呢?

----

其實我們可以不用只開一維!
我們可以紀錄上一步是走幾階到達第 i 階的方法數
也就是 $dp[i][1],dp[i][2],dp[i][3]$
分別代表上一步是走幾階到達第 i 層的方法數

----

狀態講完了，轉移式要怎麼寫呢?
因為上一步走的階數跟這一次走的階數一定要不一樣
所以我們每一次要更新的話都要找跟他階數不一樣的
以走一階為例，我們的更新方式如下：
$dp[i][1]=dp[i-1][2]+dp[i-1][3]$

----

我們寫完狀態跟轉移式了，最後只剩初始條件的判斷
大家可以先自己想一想，用紙筆推看看
下面是程式碼，想不出來的話再看喔
:::spoiler 參考code
```cpp=
const int mod = 1e9 + 7;
const int maxn = 1e6 + 50;
int dp[maxn][4];
signed main(){
	loli;
	int n;
	cin >> n;
	dp[1][1] = dp[2][2] = dp[3][3] = dp[3][1] = dp[3][2] = 1LL;
	for(int i = 4; i <= n; i ++){
		dp[i][1] = (dp[i - 1][2] + dp[i - 1][3]) % mod;
		dp[i][2] = (dp[i - 2][1] + dp[i - 2][3]) % mod;
		dp[i][3] = (dp[i - 3][1] + dp[i - 3][2]) % mod;
	}
	cout << (dp[n][1] + dp[n][2] + dp[n][3]) % mod << "\n";
}
```
:::

----

### DP的時間複雜度

最後回到時間複雜度
DP要怎麼算時間複雜度呢

----


#### DP時間複雜度 = 狀態數量 * 轉移複雜度

以上面爬樓梯問題之三為例：

狀態數量 $O(3 \times n)=O(n)$

轉移複雜度：從子狀態變成大狀態花的時間複雜度
在這題就只有加法運算，所以就是 $O(1)$

最後就是 $O(n) \times O(1)=O(n)$

---

## 經典問題

----

剛剛我們看的問題都是計數型的問題
我們來看一點最佳化的問題吧

----

### 例題：採果實問題
給你一個$N \times N$的棋盤，每個座標上有一些果實
起點在$(1,1)$的位置上(左上角)，只能往右或往下走
每經過一個座標可以上面把所有的果實拿走
求走到$(N,N)$最多可以拿到多少果實。

----

#### **狀態**

容易想到這題的狀態是走到座標$(i,j)$時可以拿到最多的果實數是多少
可以發現一件事，雖然有很多種方法可以走到$(i,j)$
但是我們都只取他的最大值

$dp[i][j]$ 代表走到座標$(i,j)$時最多可以拿到多少果實

----

#### **轉移式**

因為只能往右或往下走
所以一個位置只會從他的左邊跟上面走過來
那我們就只要取他左邊跟上面的最大值
再加上自己的果實數就是答案了

$dp[i][j]=max(dp[i-1][j],dp[i][j-1])+a[i][j]$

----

#### 邊界條件

如果直接用上面的轉移式的話可能會戳到像$(0,1)$
這樣超出棋盤外面的格子，我們有兩個方法解決他：
1. 直接把一開始所有的$dp[i][j]$設為0，這樣取最大值就不會取到他了
2. 寫一個判斷讓他超過邊界的時候不要計算

----

#### 參考CODE
:::spoiler code
```cpp=
#include<bits/stdc++.h>
using namespace std;
int dp[1005][1005], a[1005][1005];
int main(){
    int n;
    cin >> n;
    for(int i = 1; i <= n; i ++){
        for(int j = 1; j <= n; j ++){
            cin >> a[i][j];
        }
    }
    for(int i = 1; i <= n; i ++){
        for(int j = 1; j <= n; j ++){
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + a[i][j];
        }
    }
    cout << dp[n][n] << "\n";
}
```
:::

----

### 一不小心就假解

名詞解釋：假解
你以為你自己對了，其實你是錯的

----

### 例題：找零錢問題

給你若干種幣值，請問最少要幾枚硬幣才可以達到給定的值
[[連結]](http://www.tcgs.tc.edu.tw:1218/ShowProblem?problemid=b028)

----

我們先來考慮一個貪心的策略
如果我們每一次都從最大的取OK嗎?
如果題目給的是 $1,5,10,50$
且給定價值是 $78$
那麼很顯然從50開始往下取會是最好的
那他是對的嗎?

----

如果題目給的是 $1,4,9$ ，且給定值是 $12$
如果我們從 $9$ 開始選，這樣的話至少要選 $4$個
但是如果我們從 $4$ 開始選，這樣就只需要選 $3$ 個
#### 策略錯誤!

----

**既然貪心策略是錯的，那我們就來考慮動態規劃吧!**

思考time

----

#### **狀態**

這題也是一個最佳化問題，所以容易想到以下狀態

$dp[i]$ 代表湊成 $i$ 元最少要多少個硬幣

----

#### **轉移**

對於每一個狀態，考慮有什麼情形會變成這個狀態
也就是加上每一種幣值變成他的情形
所以就枚舉所有幣值變成他最少要幾枚就可以了
$dp[i]=\min\limits_{\forall j\in[1,m]} \{dp[i-a[j]]\}$

----

#### 數學符號解釋

$dp[i]=\min\limits_{j\in[1,n]} \{dp[i-a[j]]\}$
上面寫了這一個恐怖的東西，稍微來解釋一下吧

$min$ 就是取後面那個東西的最小值的意思
$min$ 下面有一個 $\forall j\in[1,m]$
中文是對於所有的 $j$ 屬於 $[1,m]$ 的集合中
意思是讓 $j$ 把所有的 $1$ 到 $m$ 跑一遍

----

#### 常見數學符號解釋

$\forall$：對於所有
$\in$：屬於
$\lceil x \rceil$：對 $x$ 向上取整 ex: $\lceil 3.1 \rceil=4$
$\lfloor x \rfloor$：對 $x$ 向下取整 ex: $\lceil 3.1 \rceil=3$

----

```cpp=
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
#define int long long
using namespace std;
const int a[6] = {1, 5, 10, 12, 16, 20};
int dp[105];

signed main(){
	int n;
	memset(dp, 0x3f, sizeof(dp));
	cin >> n;
	dp[0] = 0;
	for(int i = 1; i <= n; i ++) {
		for(int j = 0; j < 6; j ++) {
			if(i >= a[j]) dp[i] = min(dp[i], dp[i - a[j]] + 1);
		}
	}
	cout << dp[n] << "\n";
}

```

----

剛剛看的所有轉移式的複雜度都是 $O(1)$
現在我們來看一題轉移複雜度不一樣的吧!

----

### 例題：最長遞增子序列(LIS)

最長遞增子序列的意思就是從一個陣列中選出若干個位置
使得其值隨著位置增加而遞增(嚴格)
請找出最長遞增子序列的大小
範例：2, 5, 4, 7, 6, 6
最長的 LIS 是[2, 5, 7]或[2, 4, 6]，所以長度為3
注意一下這邊[2, 6, 6]不是一組解，因為他非嚴格

----

### 狀態

這題的狀態跟前面不太一樣，沒有那麼直觀
如果我們用前 $i$ 個的 $LIS$ 長度作為我們的狀態
這樣的話不一定會滿足嚴格遞增
例如：1, 3, 5, 4
如果按照上面的狀態，dp[3] = 3
但是dp[4]就無從更新了

----

$dp[i]$ 為一定要選第 $i$ 個的 $LIS$ 長度

----

#### 轉移

剛才說過這題的轉移比較不一樣，他不是 $O(1)$ 轉移

$dp[j]=\max\limits_{i<j,a[i]<a[j]}\{dp[i]+1\}$

----

參考code
```cpp=
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
#define int long long
using namespace std;
int dp[105], a[105];
#define INF 0x3f3f3f3f

signed main(){
	int n;
	cin >> n;
	for(int i = 1 ; i <= n; i ++) cin >> a[i];
	for(int i = 1; i <= n; i ++) {
		for(int j = 0; j < i; j ++) {
			if(a[j] < a[i]) dp[i] = max(dp[j] + 1, dp[i]);
		}
	}
	cyout << *max_element(dp + 1, dp + n + 1) << "\n";
}
```

----

### 例題：最長公共子序列(LCS)

給你兩個字串，請你找出最長的公共子序列。
範例：$A="abcd"$, $b="cdba"$
他們的 $LCS$ 長度是 $2$，其中 $LCS$ 為 $"cd"$
這題要印出任意一個LCS [[連結]](https://atcoder.jp/contests/dp/tasks/dp_f)

----

先考慮比較簡單的問題
如果只要求 $LCS$ 的長度要怎麼做呢？

----

#### 狀態

這題的狀態還不算太難
$dp[i][j]$ 代表 $A_1...A_i$ 跟 $B_1...B_j$ 的LCS
但是轉移就不太好想了
轉移提示：分兩種 $case$ 討論

----

#### 轉移

```cpp=
if(a[i] == b[j])
dp[i][j] = max({dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1] + 1});
else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
```
有很多東西都長的一樣，所以可以把他們合併

```cpp=
dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
if(a[i] == b[j])
    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1);
```

----

現在求出最大長度了，路徑要怎麼求呢?

----

#### 常用技巧 -- 二維陣列存路徑

我們可以開一個二維陣列存路徑

----

:::spoiler Code

```cpp=
#include<bits/stdc++.h>
#define int long long
#define pb emplace_back
#define INF 0x3f3f3f3f
#define f first
#define s second
#define pii pair<int, int>
#define mod 1000000007
#define all(x) x.begin(), x.end()
#define mem(x, a) memset(x, a, sizeof(x))
#define loli ios_base::sync_with_stdio(0), cin.tie(0)
using namespace std;
const int maxn = 1e6 + 50;
int dp[3005][3005];
pii pre[3005][3005], path[3005][3005];
 
signed main(){
	loli;
	string a, b;
	cin >> a >> b;
	int n = a.size(), m = b.size();
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= m; j ++){
 
			if(a[i - 1] == b[j - 1]){
				dp[i][j] = dp[i - 1][j - 1] + 1;
				pre[i][j] = {i - 1, j - 1};
			}
			if(dp[i][j] < dp[i - 1][j]){
				dp[i][j] = dp[i - 1][j];
				pre[i][j] = {i - 1, j};
			}
			if(dp[i][j] < dp[i][j - 1]){
				dp[i][j] = dp[i][j - 1];
				pre[i][j] = {i, j - 1};
			}
		}
	}
	string s;
	int x = pre[n][m].f, y = pre[n][m].s, px = n, py = m;
	while(1){
		if(dp[x][y] != dp[px][py]) s += a[px - 1];
		if(!x and !y) break;
		px = x;
		py = y;
		x = pre[px][py].f;
		y = pre[px][py].s;
	}
	reverse(all(s));
	cout << s << "\n";
}
```

:::

----

### 例題：01背包問題 [[連結]](http://www.tcgs.tc.edu.tw:1218/ShowProblem?problemid=b030)

現在給你 $N$ 個物品跟一個限重為 $M$ 的背包。
第 $i$ 個物品重 $W_i$，且每個物品的價值是 $V_i$。
請問你最多可以拿走多少價值的物品。
例子：第一行為物品數以及背包限重
接下來 $N$ 行每一行代表第 $i$ 個物品的重量以及價值
```cpp=
4 9
2 3 
3 4
4 5
5 6
```

----

先來分析一下題目條件。

題目的條件有：
有 $N$ 個物品，
背包的限重
每個物品的重量
每個物品的價值

題目問的是在限重之內可以帶走多少的價值。

----

所以我們可以這樣設計 $dp$ 狀態

開一個二維陣列 $dp[i][j]$ ：

$i$ 代表目前是從第 $1\sim i$ 個物品選
$j$ 代表目前選的重量為 $j$
$dp[i][j]$ 代表在此狀態下可以取到最大的價值

----

有了狀態我們就可以來想轉移式了

如果我們已經處理完從 $1\sim i-1$的物品裡去選，
所有重量可能取到的最大價值，我們要怎麼轉移呢？

提示：每個物品只有兩種情形，選或不選

----

#### 轉移

$dp[i][j]=max(dp[i-1][j],dp[i-1][j-W[i]]+ V[i])$

----

從 $1\sim i-1$的物品裡去選
最大重量為 $j$ 可以取到的最大價值是以下兩個的 $max$

1. 從 $1\sim i-1$的物品裡去選
    最大重量為 $j$ 的最大價值(不選第 $i$ 個)
    
2. 從 $1\sim i-1$的物品裡去選
    最大重量為 $j-w[i]$ 的最大價值加上第 $i$ 個物品的價值(選第 $i$ 個)

----

部份程式碼：
```cpp=
int N, M, W[105], V[105], dp[105][1005];
// 注意一下這邊的陣列都是開在全域，所以初值為0
for(int i = 1; i <= N; i ++){
    for(int j = 0; j <= M; j ++){
        if(j >= W[i]) dp[i][j] = dp[i - 1][j - W[i]] + V[i];
        dp[i][j] = max(dp[i - 1][j], dp[i][j]);
    }
}
```

----

### 延伸例題 無限背包問題 [[連結]](http://www.tcgs.tc.edu.tw:1218/ShowProblem?problemid=b031)

跟01背包問題一樣，但是每個物品可以取無限次。

----

#### 狀態

其實跟01背包問題示一模一樣的

一個二維陣列 $dp[i][j]$

$i$ 代表目前是從第 $1\sim i$ 個物品選
$j$ 代表目前選的重量為 $j$
$dp[i][j]$ 代表在此狀態下可以取到最大的價值

----

#### 轉移

這個就跟01背包問題有不一樣的地方了
可以注意到在01背包問題的時候，我們是從
$dp[i-1][j]$ 跟 $dp[i-1][j-W[i]]$ 轉移過來的
原因是每個物品都只有一個，所以要從前$i-1$個去取
但是我們現在可以取無限次！

所以我們直接從 $dp[i-1][j]$ 跟 $dp[i][j-W[i]]$ 取就可以了

----

#### 轉移式

$dp[i][j]=max(dp[i-1][j], dp[i][j - W[i]] + V[i])$

----

### 回家作業 有限背包問題 [[連結]](https://tioj.ck.tp.edu.tw/problems/1387)

題目跟01背包問題一樣
但是現在每個物品最多可以取$C_i$ 個

#### 下禮拜公佈答案

----

看完01背包跟無限背包問題可以發現到一件事情
其實每一次都是從 $i-1$ 或 $i$ 轉移過來的
那就代表每次轉移都只需要前一次的結果
$i-2$ 以前的東西不會再被用到了！

----

### 小技巧 -- 滾動數組

意思就是只存當下轉移會需要的狀態
其他的狀態可以直接捨棄不理他

那如果我們開兩個一維陣列來用可以嗎？
```cpp=
int pre[1005], now[1005];
```

這樣的話我們可能每一次都要做一次複製的動作
有一點小小的麻煩，有沒有更好的辦法？

----

### 小技巧 -- 滾動數組

可以開一個二維陣列 $dp[2][1005]$

當我們在做 $dp[0][j]$ 的時候，就從 $dp[1][j]$ 轉移

在做 $dp[1][j]$ 的時候，就從 $dp[0][j]$ 轉移

實作細節一樣當作業留給大家，如果不會可以來問我

----

### 小技巧 -- 滾動數組2

那可不可以只開一維？其實可以！
無限背包的話可以直接拿掉
但是01背包的 for 迴圈寫法就要稍微改一下了
直接上 code
```cpp=
// 01背包程式碼
int N, M, dp[1005], W[1005], V[1005];
for(int i = 1; i <= n; i ++){
    for(int j = M; j >= W[i]; j --){
        dp[j] = max(dp[j], dp[j - W[i]] + V[i]);
    }
}
```

----

為什麼要改呢？
如果我們用之前的作法，就不能剛好從 $1\sim i-1$ 轉移
因為在取 $dp[j-W[i]]$ 的時候，可能已經被第 $i$ 個物品更新過了。
所以為了保證我們在轉移的時候不會重複選到
其實只要先從 $M$ 開始往下轉移就可以了

----


---

## 題單
[[atcoder dp contest]](https://atcoder.jp/contests/dp/tasks)
[[DP practice]](https://vjudge.net/contest/413333)

